// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mock

//go:generate minimock -i route256/loms/internal/service/loms.OrdersRepository -o orders_repository_mock.go -n OrdersRepositoryMock -p mock

import (
	"context"
	"route256/loms/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrdersRepositoryMock implements lomsusecase.OrdersRepository
type OrdersRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, userID int64, items []domain.Item) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, userID int64, items []domain.Item)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mOrdersRepositoryMockCreate

	funcGetByID          func(ctx context.Context, orderID int64) (op1 *domain.Order, err error)
	inspectFuncGetByID   func(ctx context.Context, orderID int64)
	afterGetByIDCounter  uint64
	beforeGetByIDCounter uint64
	GetByIDMock          mOrdersRepositoryMockGetByID

	funcSetStatus          func(ctx context.Context, orderID int64, status string) (err error)
	inspectFuncSetStatus   func(ctx context.Context, orderID int64, status string)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mOrdersRepositoryMockSetStatus
}

// NewOrdersRepositoryMock returns a mock for lomsusecase.OrdersRepository
func NewOrdersRepositoryMock(t minimock.Tester) *OrdersRepositoryMock {
	m := &OrdersRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mOrdersRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*OrdersRepositoryMockCreateParams{}

	m.GetByIDMock = mOrdersRepositoryMockGetByID{mock: m}
	m.GetByIDMock.callArgs = []*OrdersRepositoryMockGetByIDParams{}

	m.SetStatusMock = mOrdersRepositoryMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*OrdersRepositoryMockSetStatusParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrdersRepositoryMockCreate struct {
	optional           bool
	mock               *OrdersRepositoryMock
	defaultExpectation *OrdersRepositoryMockCreateExpectation
	expectations       []*OrdersRepositoryMockCreateExpectation

	callArgs []*OrdersRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrdersRepositoryMockCreateExpectation specifies expectation struct of the OrdersRepository.Create
type OrdersRepositoryMockCreateExpectation struct {
	mock      *OrdersRepositoryMock
	params    *OrdersRepositoryMockCreateParams
	paramPtrs *OrdersRepositoryMockCreateParamPtrs
	results   *OrdersRepositoryMockCreateResults
	Counter   uint64
}

// OrdersRepositoryMockCreateParams contains parameters of the OrdersRepository.Create
type OrdersRepositoryMockCreateParams struct {
	ctx    context.Context
	userID int64
	items  []domain.Item
}

// OrdersRepositoryMockCreateParamPtrs contains pointers to parameters of the OrdersRepository.Create
type OrdersRepositoryMockCreateParamPtrs struct {
	ctx    *context.Context
	userID *int64
	items  *[]domain.Item
}

// OrdersRepositoryMockCreateResults contains results of the OrdersRepository.Create
type OrdersRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mOrdersRepositoryMockCreate) Optional() *mOrdersRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for OrdersRepository.Create
func (mmCreate *mOrdersRepositoryMockCreate) Expect(ctx context.Context, userID int64, items []domain.Item) *mOrdersRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrdersRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &OrdersRepositoryMockCreateParams{ctx, userID, items}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for OrdersRepository.Create
func (mmCreate *mOrdersRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mOrdersRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrdersRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrdersRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreate
}

// ExpectUserIDParam2 sets up expected param userID for OrdersRepository.Create
func (mmCreate *mOrdersRepositoryMockCreate) ExpectUserIDParam2(userID int64) *mOrdersRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrdersRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrdersRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.userID = &userID

	return mmCreate
}

// ExpectItemsParam3 sets up expected param items for OrdersRepository.Create
func (mmCreate *mOrdersRepositoryMockCreate) ExpectItemsParam3(items []domain.Item) *mOrdersRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrdersRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrdersRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.items = &items

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.Create
func (mmCreate *mOrdersRepositoryMockCreate) Inspect(f func(ctx context.Context, userID int64, items []domain.Item)) *mOrdersRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by OrdersRepository.Create
func (mmCreate *mOrdersRepositoryMockCreate) Return(i1 int64, err error) *OrdersRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrdersRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &OrdersRepositoryMockCreateResults{i1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the OrdersRepository.Create method
func (mmCreate *mOrdersRepositoryMockCreate) Set(f func(ctx context.Context, userID int64, items []domain.Item) (i1 int64, err error)) *OrdersRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the OrdersRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mOrdersRepositoryMockCreate) When(ctx context.Context, userID int64, items []domain.Item) *OrdersRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrdersRepositoryMock.Create mock is already set by Set")
	}

	expectation := &OrdersRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &OrdersRepositoryMockCreateParams{ctx, userID, items},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up OrdersRepository.Create return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockCreateExpectation) Then(i1 int64, err error) *OrdersRepositoryMock {
	e.results = &OrdersRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times OrdersRepository.Create should be invoked
func (mmCreate *mOrdersRepositoryMockCreate) Times(n uint64) *mOrdersRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of OrdersRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	return mmCreate
}

func (mmCreate *mOrdersRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements lomsusecase.OrdersRepository
func (mmCreate *OrdersRepositoryMock) Create(ctx context.Context, userID int64, items []domain.Item) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, userID, items)
	}

	mm_params := OrdersRepositoryMockCreateParams{ctx, userID, items}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := OrdersRepositoryMockCreateParams{ctx, userID, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("OrdersRepositoryMock.Create got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmCreate.t.Errorf("OrdersRepositoryMock.Create got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmCreate.t.Errorf("OrdersRepositoryMock.Create got unexpected parameter items, want: %#v, got: %#v%s\n", *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("OrdersRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the OrdersRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, userID, items)
	}
	mmCreate.t.Fatalf("Unexpected call to OrdersRepositoryMock.Create. %v %v %v", ctx, userID, items)
	return
}

// CreateAfterCounter returns a count of finished OrdersRepositoryMock.Create invocations
func (mmCreate *OrdersRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of OrdersRepositoryMock.Create invocations
func (mmCreate *OrdersRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mOrdersRepositoryMockCreate) Calls() []*OrdersRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*OrdersRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrdersRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to OrdersRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Error("Expected call to OrdersRepositoryMock.Create")
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersRepositoryMock.Create but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), afterCreateCounter)
	}
}

type mOrdersRepositoryMockGetByID struct {
	optional           bool
	mock               *OrdersRepositoryMock
	defaultExpectation *OrdersRepositoryMockGetByIDExpectation
	expectations       []*OrdersRepositoryMockGetByIDExpectation

	callArgs []*OrdersRepositoryMockGetByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrdersRepositoryMockGetByIDExpectation specifies expectation struct of the OrdersRepository.GetByID
type OrdersRepositoryMockGetByIDExpectation struct {
	mock      *OrdersRepositoryMock
	params    *OrdersRepositoryMockGetByIDParams
	paramPtrs *OrdersRepositoryMockGetByIDParamPtrs
	results   *OrdersRepositoryMockGetByIDResults
	Counter   uint64
}

// OrdersRepositoryMockGetByIDParams contains parameters of the OrdersRepository.GetByID
type OrdersRepositoryMockGetByIDParams struct {
	ctx     context.Context
	orderID int64
}

// OrdersRepositoryMockGetByIDParamPtrs contains pointers to parameters of the OrdersRepository.GetByID
type OrdersRepositoryMockGetByIDParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// OrdersRepositoryMockGetByIDResults contains results of the OrdersRepository.GetByID
type OrdersRepositoryMockGetByIDResults struct {
	op1 *domain.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByID *mOrdersRepositoryMockGetByID) Optional() *mOrdersRepositoryMockGetByID {
	mmGetByID.optional = true
	return mmGetByID
}

// Expect sets up expected params for OrdersRepository.GetByID
func (mmGetByID *mOrdersRepositoryMockGetByID) Expect(ctx context.Context, orderID int64) *mOrdersRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("OrdersRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &OrdersRepositoryMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.paramPtrs != nil {
		mmGetByID.mock.t.Fatalf("OrdersRepositoryMock.GetByID mock is already set by ExpectParams functions")
	}

	mmGetByID.defaultExpectation.params = &OrdersRepositoryMockGetByIDParams{ctx, orderID}
	for _, e := range mmGetByID.expectations {
		if minimock.Equal(e.params, mmGetByID.defaultExpectation.params) {
			mmGetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByID.defaultExpectation.params)
		}
	}

	return mmGetByID
}

// ExpectCtxParam1 sets up expected param ctx for OrdersRepository.GetByID
func (mmGetByID *mOrdersRepositoryMockGetByID) ExpectCtxParam1(ctx context.Context) *mOrdersRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("OrdersRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &OrdersRepositoryMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("OrdersRepositoryMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &OrdersRepositoryMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetByID
}

// ExpectOrderIDParam2 sets up expected param orderID for OrdersRepository.GetByID
func (mmGetByID *mOrdersRepositoryMockGetByID) ExpectOrderIDParam2(orderID int64) *mOrdersRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("OrdersRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &OrdersRepositoryMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("OrdersRepositoryMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &OrdersRepositoryMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.orderID = &orderID

	return mmGetByID
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.GetByID
func (mmGetByID *mOrdersRepositoryMockGetByID) Inspect(f func(ctx context.Context, orderID int64)) *mOrdersRepositoryMockGetByID {
	if mmGetByID.mock.inspectFuncGetByID != nil {
		mmGetByID.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.GetByID")
	}

	mmGetByID.mock.inspectFuncGetByID = f

	return mmGetByID
}

// Return sets up results that will be returned by OrdersRepository.GetByID
func (mmGetByID *mOrdersRepositoryMockGetByID) Return(op1 *domain.Order, err error) *OrdersRepositoryMock {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("OrdersRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &OrdersRepositoryMockGetByIDExpectation{mock: mmGetByID.mock}
	}
	mmGetByID.defaultExpectation.results = &OrdersRepositoryMockGetByIDResults{op1, err}
	return mmGetByID.mock
}

// Set uses given function f to mock the OrdersRepository.GetByID method
func (mmGetByID *mOrdersRepositoryMockGetByID) Set(f func(ctx context.Context, orderID int64) (op1 *domain.Order, err error)) *OrdersRepositoryMock {
	if mmGetByID.defaultExpectation != nil {
		mmGetByID.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.GetByID method")
	}

	if len(mmGetByID.expectations) > 0 {
		mmGetByID.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.GetByID method")
	}

	mmGetByID.mock.funcGetByID = f
	return mmGetByID.mock
}

// When sets expectation for the OrdersRepository.GetByID which will trigger the result defined by the following
// Then helper
func (mmGetByID *mOrdersRepositoryMockGetByID) When(ctx context.Context, orderID int64) *OrdersRepositoryMockGetByIDExpectation {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("OrdersRepositoryMock.GetByID mock is already set by Set")
	}

	expectation := &OrdersRepositoryMockGetByIDExpectation{
		mock:   mmGetByID.mock,
		params: &OrdersRepositoryMockGetByIDParams{ctx, orderID},
	}
	mmGetByID.expectations = append(mmGetByID.expectations, expectation)
	return expectation
}

// Then sets up OrdersRepository.GetByID return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockGetByIDExpectation) Then(op1 *domain.Order, err error) *OrdersRepositoryMock {
	e.results = &OrdersRepositoryMockGetByIDResults{op1, err}
	return e.mock
}

// Times sets number of times OrdersRepository.GetByID should be invoked
func (mmGetByID *mOrdersRepositoryMockGetByID) Times(n uint64) *mOrdersRepositoryMockGetByID {
	if n == 0 {
		mmGetByID.mock.t.Fatalf("Times of OrdersRepositoryMock.GetByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByID.expectedInvocations, n)
	return mmGetByID
}

func (mmGetByID *mOrdersRepositoryMockGetByID) invocationsDone() bool {
	if len(mmGetByID.expectations) == 0 && mmGetByID.defaultExpectation == nil && mmGetByID.mock.funcGetByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByID.mock.afterGetByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByID implements lomsusecase.OrdersRepository
func (mmGetByID *OrdersRepositoryMock) GetByID(ctx context.Context, orderID int64) (op1 *domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetByID.beforeGetByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByID.afterGetByIDCounter, 1)

	if mmGetByID.inspectFuncGetByID != nil {
		mmGetByID.inspectFuncGetByID(ctx, orderID)
	}

	mm_params := OrdersRepositoryMockGetByIDParams{ctx, orderID}

	// Record call args
	mmGetByID.GetByIDMock.mutex.Lock()
	mmGetByID.GetByIDMock.callArgs = append(mmGetByID.GetByIDMock.callArgs, &mm_params)
	mmGetByID.GetByIDMock.mutex.Unlock()

	for _, e := range mmGetByID.GetByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetByID.GetByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByID.GetByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByID.GetByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetByID.GetByIDMock.defaultExpectation.paramPtrs

		mm_got := OrdersRepositoryMockGetByIDParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByID.t.Errorf("OrdersRepositoryMock.GetByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetByID.t.Errorf("OrdersRepositoryMock.GetByID got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByID.t.Errorf("OrdersRepositoryMock.GetByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByID.GetByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByID.t.Fatal("No results are set for the OrdersRepositoryMock.GetByID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetByID.funcGetByID != nil {
		return mmGetByID.funcGetByID(ctx, orderID)
	}
	mmGetByID.t.Fatalf("Unexpected call to OrdersRepositoryMock.GetByID. %v %v", ctx, orderID)
	return
}

// GetByIDAfterCounter returns a count of finished OrdersRepositoryMock.GetByID invocations
func (mmGetByID *OrdersRepositoryMock) GetByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.afterGetByIDCounter)
}

// GetByIDBeforeCounter returns a count of OrdersRepositoryMock.GetByID invocations
func (mmGetByID *OrdersRepositoryMock) GetByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.beforeGetByIDCounter)
}

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.GetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByID *mOrdersRepositoryMockGetByID) Calls() []*OrdersRepositoryMockGetByIDParams {
	mmGetByID.mutex.RLock()

	argCopy := make([]*OrdersRepositoryMockGetByIDParams, len(mmGetByID.callArgs))
	copy(argCopy, mmGetByID.callArgs)

	mmGetByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDDone returns true if the count of the GetByID invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockGetByIDDone() bool {
	if m.GetByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIDMock.invocationsDone()
}

// MinimockGetByIDInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockGetByIDInspect() {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersRepositoryMock.GetByID with params: %#v", *e.params)
		}
	}

	afterGetByIDCounter := mm_atomic.LoadUint64(&m.afterGetByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && afterGetByIDCounter < 1 {
		if m.GetByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrdersRepositoryMock.GetByID")
		} else {
			m.t.Errorf("Expected call to OrdersRepositoryMock.GetByID with params: %#v", *m.GetByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && afterGetByIDCounter < 1 {
		m.t.Error("Expected call to OrdersRepositoryMock.GetByID")
	}

	if !m.GetByIDMock.invocationsDone() && afterGetByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersRepositoryMock.GetByID but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIDMock.expectedInvocations), afterGetByIDCounter)
	}
}

type mOrdersRepositoryMockSetStatus struct {
	optional           bool
	mock               *OrdersRepositoryMock
	defaultExpectation *OrdersRepositoryMockSetStatusExpectation
	expectations       []*OrdersRepositoryMockSetStatusExpectation

	callArgs []*OrdersRepositoryMockSetStatusParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrdersRepositoryMockSetStatusExpectation specifies expectation struct of the OrdersRepository.SetStatus
type OrdersRepositoryMockSetStatusExpectation struct {
	mock      *OrdersRepositoryMock
	params    *OrdersRepositoryMockSetStatusParams
	paramPtrs *OrdersRepositoryMockSetStatusParamPtrs
	results   *OrdersRepositoryMockSetStatusResults
	Counter   uint64
}

// OrdersRepositoryMockSetStatusParams contains parameters of the OrdersRepository.SetStatus
type OrdersRepositoryMockSetStatusParams struct {
	ctx     context.Context
	orderID int64
	status  string
}

// OrdersRepositoryMockSetStatusParamPtrs contains pointers to parameters of the OrdersRepository.SetStatus
type OrdersRepositoryMockSetStatusParamPtrs struct {
	ctx     *context.Context
	orderID *int64
	status  *string
}

// OrdersRepositoryMockSetStatusResults contains results of the OrdersRepository.SetStatus
type OrdersRepositoryMockSetStatusResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatus *mOrdersRepositoryMockSetStatus) Optional() *mOrdersRepositoryMockSetStatus {
	mmSetStatus.optional = true
	return mmSetStatus
}

// Expect sets up expected params for OrdersRepository.SetStatus
func (mmSetStatus *mOrdersRepositoryMockSetStatus) Expect(ctx context.Context, orderID int64, status string) *mOrdersRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrdersRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrdersRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.paramPtrs != nil {
		mmSetStatus.mock.t.Fatalf("OrdersRepositoryMock.SetStatus mock is already set by ExpectParams functions")
	}

	mmSetStatus.defaultExpectation.params = &OrdersRepositoryMockSetStatusParams{ctx, orderID, status}
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// ExpectCtxParam1 sets up expected param ctx for OrdersRepository.SetStatus
func (mmSetStatus *mOrdersRepositoryMockSetStatus) ExpectCtxParam1(ctx context.Context) *mOrdersRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrdersRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrdersRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrdersRepositoryMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrdersRepositoryMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSetStatus
}

// ExpectOrderIDParam2 sets up expected param orderID for OrdersRepository.SetStatus
func (mmSetStatus *mOrdersRepositoryMockSetStatus) ExpectOrderIDParam2(orderID int64) *mOrdersRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrdersRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrdersRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrdersRepositoryMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrdersRepositoryMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.orderID = &orderID

	return mmSetStatus
}

// ExpectStatusParam3 sets up expected param status for OrdersRepository.SetStatus
func (mmSetStatus *mOrdersRepositoryMockSetStatus) ExpectStatusParam3(status string) *mOrdersRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrdersRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrdersRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrdersRepositoryMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrdersRepositoryMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.status = &status

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the OrdersRepository.SetStatus
func (mmSetStatus *mOrdersRepositoryMockSetStatus) Inspect(f func(ctx context.Context, orderID int64, status string)) *mOrdersRepositoryMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for OrdersRepositoryMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by OrdersRepository.SetStatus
func (mmSetStatus *mOrdersRepositoryMockSetStatus) Return(err error) *OrdersRepositoryMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrdersRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrdersRepositoryMockSetStatusExpectation{mock: mmSetStatus.mock}
	}
	mmSetStatus.defaultExpectation.results = &OrdersRepositoryMockSetStatusResults{err}
	return mmSetStatus.mock
}

// Set uses given function f to mock the OrdersRepository.SetStatus method
func (mmSetStatus *mOrdersRepositoryMockSetStatus) Set(f func(ctx context.Context, orderID int64, status string) (err error)) *OrdersRepositoryMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the OrdersRepository.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the OrdersRepository.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	return mmSetStatus.mock
}

// When sets expectation for the OrdersRepository.SetStatus which will trigger the result defined by the following
// Then helper
func (mmSetStatus *mOrdersRepositoryMockSetStatus) When(ctx context.Context, orderID int64, status string) *OrdersRepositoryMockSetStatusExpectation {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrdersRepositoryMock.SetStatus mock is already set by Set")
	}

	expectation := &OrdersRepositoryMockSetStatusExpectation{
		mock:   mmSetStatus.mock,
		params: &OrdersRepositoryMockSetStatusParams{ctx, orderID, status},
	}
	mmSetStatus.expectations = append(mmSetStatus.expectations, expectation)
	return expectation
}

// Then sets up OrdersRepository.SetStatus return parameters for the expectation previously defined by the When method
func (e *OrdersRepositoryMockSetStatusExpectation) Then(err error) *OrdersRepositoryMock {
	e.results = &OrdersRepositoryMockSetStatusResults{err}
	return e.mock
}

// Times sets number of times OrdersRepository.SetStatus should be invoked
func (mmSetStatus *mOrdersRepositoryMockSetStatus) Times(n uint64) *mOrdersRepositoryMockSetStatus {
	if n == 0 {
		mmSetStatus.mock.t.Fatalf("Times of OrdersRepositoryMock.SetStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatus.expectedInvocations, n)
	return mmSetStatus
}

func (mmSetStatus *mOrdersRepositoryMockSetStatus) invocationsDone() bool {
	if len(mmSetStatus.expectations) == 0 && mmSetStatus.defaultExpectation == nil && mmSetStatus.mock.funcSetStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatus.mock.afterSetStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatus implements lomsusecase.OrdersRepository
func (mmSetStatus *OrdersRepositoryMock) SetStatus(ctx context.Context, orderID int64, status string) (err error) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(ctx, orderID, status)
	}

	mm_params := OrdersRepositoryMockSetStatusParams{ctx, orderID, status}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, &mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatus.SetStatusMock.defaultExpectation.paramPtrs

		mm_got := OrdersRepositoryMockSetStatusParams{ctx, orderID, status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetStatus.t.Errorf("OrdersRepositoryMock.SetStatus got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmSetStatus.t.Errorf("OrdersRepositoryMock.SetStatus got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmSetStatus.t.Errorf("OrdersRepositoryMock.SetStatus got unexpected parameter status, want: %#v, got: %#v%s\n", *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("OrdersRepositoryMock.SetStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatus.SetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatus.t.Fatal("No results are set for the OrdersRepositoryMock.SetStatus")
		}
		return (*mm_results).err
	}
	if mmSetStatus.funcSetStatus != nil {
		return mmSetStatus.funcSetStatus(ctx, orderID, status)
	}
	mmSetStatus.t.Fatalf("Unexpected call to OrdersRepositoryMock.SetStatus. %v %v %v", ctx, orderID, status)
	return
}

// SetStatusAfterCounter returns a count of finished OrdersRepositoryMock.SetStatus invocations
func (mmSetStatus *OrdersRepositoryMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of OrdersRepositoryMock.SetStatus invocations
func (mmSetStatus *OrdersRepositoryMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to OrdersRepositoryMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mOrdersRepositoryMockSetStatus) Calls() []*OrdersRepositoryMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*OrdersRepositoryMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *OrdersRepositoryMock) MinimockSetStatusDone() bool {
	if m.SetStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusMock.invocationsDone()
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *OrdersRepositoryMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersRepositoryMock.SetStatus with params: %#v", *e.params)
		}
	}

	afterSetStatusCounter := mm_atomic.LoadUint64(&m.afterSetStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && afterSetStatusCounter < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrdersRepositoryMock.SetStatus")
		} else {
			m.t.Errorf("Expected call to OrdersRepositoryMock.SetStatus with params: %#v", *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && afterSetStatusCounter < 1 {
		m.t.Error("Expected call to OrdersRepositoryMock.SetStatus")
	}

	if !m.SetStatusMock.invocationsDone() && afterSetStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersRepositoryMock.SetStatus but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusMock.expectedInvocations), afterSetStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrdersRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockGetByIDInspect()

			m.MinimockSetStatusInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrdersRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrdersRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetByIDDone() &&
		m.MinimockSetStatusDone()
}
